CSS Getting Started:
	-CSS3: currently in development (In Development)
	-THERE WILL NEVER BE CSS 4: because 3 is being split into modules: (colors, animation)
	-SCHEDULE:	
		*Basic: 		Sec 2:Basics - Sec 6: Positioning
		*Advanced: 	Sec 7:Backrounds and images - Sec 12:Text and Fonts
		*Expert:		Sec 13:Flexbox - Sec 18:Sass

Diving into the Basics of CSS:
	-Inline Styles:			<someTag style="property: value;

	-<style> tags:			<style>
						selector { //A selector applies this css to all named tag <selector>
							property: value;
						}
					</style>

	-.css Files:			-You can put your CSS rules in a file like main.css
					-Link the css to html with:	<link rel="stylesheet" href="somePath"> //no closing tag

	-Properties and Values:		-backround: #345677 			//Background Color
					-color: #123456 			//Text Color
					-font-family: sans-serif 		//Changes the font family
						*You can use Google Fonts > + > Import Link above our style link > Add rule
	
	-Selectors:			-Element Selectors:
						* Applied to all tags
						* Selector is defined as follows:	someTagName{props:vals;}
					-Class Selectors:
						* Applied to tags with class="" attributes
						* Selector is defined as follows:	.someClassName{props:vals;}
					-Universal Selectors:
						* Applied to every element in the page
						* Selector is defined as follow:	* {props:vals;}
					-ID Selectors:
						* Applied to one element with id="" attribute
						* Selector is defined as follow:	#someIDName {props:vals;}
					-Attribute Selectors:
						* Applied to elements based on their attributes
						* Selector is defined as follow:	[someAttributeName] {props:vals;}

	-Cascading Style(specificity):	-Inline styles have the highest priority
					-If two rules manipulate the same property. The one with higher specificity wins
					 (ex: class selectors beats element selectors)
					-If there are multiple rules with the same selector. The last on in the file is applied
					-Specificity:(Descending from high to low priority)
						1)Inline Styles
						2)#ID selectors
						3).class, :pseudo-class and [attribute] selectors
						4)<tag> and pseudo-element selectors
						5)*Universal selector
						6)Browser provided styles

	-Inheritance:			-We can propagate down a rule simply by styling a parent that has child elements.
					-Although, if a child defines their own rule then the specificity is better for that child and overrides the parent's
					-Having a rule in the body tag is perfect for propagating rules to every element

	-Combinators:			-Allow us to combine multiple selectors to be more precise about what we select.
					-Ex:	#someID h1 {}	=	"Any h1 tag inside of #someID
					-This increases specificity
					-FOUR IMPORTANT TYPES OF COMBINATORS(examples use two, but can be more):
						1) Adjacent Sibling:
							* Notation: +
							* Ex:	h2 + p	=  "Assigns to all paragraphs that directly follow an h2 tag"
						2) General Sibling:
							* Notation: ~
							* Ex:	h2 ~ p	=  "Assigns to all paragraphs that have a sibling h2 anywhere; order doesn't matter."
						3) Child:
							* Notation: >
							* Ex:	div > p	=  "Any paragraph that's a DIRECT child of a div should get the style"
						4) Descendant
							* Notation: <whitespace>
							* Ex:	div p =    "Any paragraph that's a descendant of a div should get a style" (Direct not needed)

DIVING DEEPER INTO CSS:
	-CSS Box Model:			-In the webpage, HTML interprets elements as boxes (Check inspector below properties for visuals)
					-Every element has content, padding, border, and margins
					-CSS properties: 
							* padding: 20px; 
							* border: 5px black solid; (this is shorthand)

	-Default Margins:		-By default, the <body> element has a default margin of 8px. We can remove this with margin: 0px;

	-Margin Collapsing:		-The bigger margin of two adjacent box elements is the things that separates both from each other,
					 therefore the margins don't add up, they "collapse" onto each other.

	-Shorthand properties:		-Combine values of multiple other properties, into a single property.
						* EX:
							** Separate properties:
										border-width: 2px;
										border-style: dashed (or solid);
										border-color: orange;
							** Shorthand property:
										border: 2px solid orange;
					-The order doesn't matter as long as each property uses a different value.
					-margin has a shorthand for its margin-top , right, bottom, left properties like so:
						* margin: 5px, 10px, 5px, 10px; (in the order above) (there's a 2 side version using only two Vals for top/down)

	-Height & Width properties:	-Can have relative values (%) or absolute values (px)
					-Width can take up the full width of the page. 
					-Height can not take up the full height of a page. 100% refers to the available height given by the parent's container.
						*Quirky. 100% needs to be chained down from <html> in order to get it to work like width's 100%
						*Better to use absolute values.
					-The width and height by default manipulates only the content section our CSS box. Therefore if you add padding, borders
					 and margins. IT maybe glitchy at 100%. THIS IS BECAUSE THE PROPERTY box-sizing IS SET TO content-box by default.
					 You could set for everything before the margin section to be included in width and height calculations by setting
					 the value border-box . THIS VALUE IS SO COMMON BECAUSE THAT IS THE EFFECT WE WANT TO KEEP EVERYTHING BALANCED. ILL' REPEAT:
						
						*IMPORTANT PROPERTY (from above) - box-sizing: border-box;
						**This is something you should wrap in a universal selector for all elements to use.

	-Display Property:		-Allows us to change the behavior of an element from block to inline (bidirectional) and even remove the element from the DOM
						*Inline elements don't take the full width of the screen, and don't have margin top/bottom. Blocks do.
					-The property is display: and has the values -
						* block 	(makes an element into a block)
						* inline
						* none	(makes an element invisible in the DOM but doesn't remove it from the DOM) 
							(visibility: hidden; is similar but it blocks content from taking its place)
						* inline-block (keep the behavior of blocks, but they can go next to each other now)
							**WEIRD QUIRK: HTML reads whitespace as a node, so if you try to make two inline-blocks stay in the same
								       line using 100% and minus, you have to take into account that whitespace node's size
						* THE DIFFERENCE BETWEEN INLINE AND BOX:
							** Box take up the whole width of a document
							** Inline takes up the space that is needed for its content
								*** So we'd have to be careful in cases like:
									1) Using width 100% would make a new line away from another inline. We would have to
									   do width: 100% - someOtherInlinesWidth; to make it stay in the same line
					-Later on we see flex box which is better.
					

	-Calc():				-To yield a calculate value do something like:
						width: calc(100% - 53px) //Here whitespace between each operand matters

	-text-decoration and		-For things with default styling like anchor tags. We can do text-decoration: none; to get rid of its default styling
	 vertical-align:			-The fontSize of one thing in the "line" can effect the alignment of the others. (Ex: our logo is big and our Nav links align
					 to "touch the floor" with the big logo). We can feed the value vertical-align: middle; to remedy quirky alignment

	-Pseudo Classes			-SYNTAX:
	 (for animations?):			someSelector:pseudoclass {//rules}
					-DEFINITION:
						Defines the style of a special state of an element
					-EX:
						someSelector:hover{} //when your mouse hovers over the selected element then a rule is applied while it stays there.

	-Pseurdo Elements:		-SYNTAX
						someSelector::pseudoclass {/rules}
					-DEFINITION:
						Define the style of a specific part of an enemy
					-EX:
						someSelector::after{content: "(Link)"} //Puts the text in content after the selected element

	-Grouping Rules:			-Simply comma separate selectors. And the rules will be applied to all

	-border-bottom:			-Value: 5px solid white; //to add a white line below a link
	
	-Tags with multiple		-This can be done by adding another className to the attribute after a space
	 class="":

	-Adding an image:		-SYNTAX:
						background: url("freedom.jpg");

	-PROPERTIES WORTH 
	 REMEMBERING:			-color
					-background-color
					-display
					-padding
					-border
					-margin
					-width
					-height


MORE ON SELECTORS & CSS FEATURES:
	-Tags can have more than one class in the class attribute (separated by white space)
		*We can make separate rules for each class. Though if they manipulate the same thing order matters (down most in CSS file)

	-Select by Class:		Syntax:	tagType.className {}  //Targets an element which is of tagType and has the className CSS class

	-Overwrite specificity		Syntax:
	 using !important:			div { color: red !important;}	//You SHOUL NOT USE this. Leads to bad code

	-Selecting the opposite		Syntax:
	 with :not() pseudo class:		a:not(someSelector) {}	//Select any anchor tag that does not have class="someSelector"


PRACTICING THE BASICS:
	-text-align property:		*To align the text to the center (width-wise) the value should be: center
	
	-box-shadow property:		Syntax:		box-shadow: 2px 2px 2px 2px rgba(0, 0, 0, 0.5);		//Yield a "box shadow" on your selection, NOTICE the COLOR FUNCTION rgba()

	-border-radius property:	Syntax:		border-radius: 8px; //for all corners		border-radius: 4px 4px 4px 4px //To define every corner

	-Cursor when we hover		Syntax:		cursor: pointer;
	 over buttons:		
	
	-For buttons use			*:hover and :active can change the color to make it more pleasant
	 Pseudoclasses:

	-When you focus on a 		*Syntax:	.button:focus{ outline: none;}
	 button there's a
	 default annoying blue
	 outline. Solve w/:

	-Vertical align thing:		*Use it on the parent of things you want to vertically align

	-Turning a block into		*Syntax:	border-radius: 50%;
	 a perfect circle:				width: 128px; height: 128px;	//Where both w/h need to be the same

	-To center things		*Syntax:	margin: auto;	//which centers on all directions (mostly horizontally)
	 horizontally:

	-"floats":			*Definition:	Overwrite default positioning and tell the broswer to an element should go to the left or right (isn't used much now because we have flexbox now)
					*Warning:	It takes the element out of the document flow. (other elements can overlap under it). To prevent this we define an empty div behind this element that has
							the rule clear: both;

POSITIONING ELEMENTS WITH CSS:
	-Positioning Theory:		* The position property is applied by default with the value static
					* position can hold the values:	static, absolute, relative, fixed, sticky		//"move to another position."
					* But it must also define where it should be placed so we have properties:		//"ok, but where should I move to?"
						** left, right, bottom, left (or combos of these)
						** When top is defined with a value of say 20 px It can have two meanings:  //positioning context is always the viewport
							1) "Move the current element 20px above where it currently is."
							2) "Move the current element 20px from the top of some element"
					*top, left, etc takes effect on when position is anything but static

	-Working with "fixed":		*When you first define "position: fixed;" you'll see that elements below the "fixed" overtake it and it's width act like an inline-block.
					 This happens because we took it out of the "document flow" (this element doesn't exist to the others)
					*When you define "top: 0px" (and make sure your margin is 0): WE SEE THAT IT IS FIXED RELATIVE TO THE BROWSER VIEWPORT.
					*So if you define a property left & top with 0 values, then it is "fixed" starting at the top left!

	-"position" to add a		* Properties:
	 background image:			** background: url("somePathToImage");
						** position: fixed;
						** width & height: 100%;

	-Understanding the		* By default every element has a z-property with the value auto (which is equal to 0)
	 "z-axis" property:		* So to stack things above. Choose any number greater than what you want to stack above. And below, less than (can be negative)
						** two values w/ same Z rely on the order of the HTML to appear
					* IMPORTANT: z-index only works with elements that have the position property with any value except for static.

	-Adding a badge to our		* The absolute property. The positioning context is defined by TWO CASES:
	 Package (absolute):			1) If none of the ancestors of the element has a position property define. Then the positioning context of our element is the <html>
						   element
						2) If not (1) then the closest ancestor w/ a position is the positioning context for this element
					* absolute also breaks the "flow"

	-Styling & Positioning		* Use relative to not "break" the flow and in order to let an absolute have it's position relative to that relative.
	 w/ absolute & relative:		* We could have our top, left, right, bottom to be equal to 0 and let margins define the distance away.

	-Diving Deeper into relative:	*DOESN'T BREAK FLOW
					*IDEAL TO SETUP POSITIONING CONTEXT's FOR OTHER ELEMENT's that use absolute.
					*When top, left, right, bottom are used on elements that have the property RELATIVE. Then it move's offset to it's "flow" position.
					 AND WHEN YOU DO THIS IT STILL ISN'T TAKEN OUT OF ITS FLOW!!!

	-Working w/ "overflow" &		* On the rule w/ the parent selected add:		overflow: hidden;
	 relative positioning (to		* A WEIRD QUIRK OF HTML: if overflow: hidden; is passed to a <body>, it erases it and passes it to the <html>
	 prevent offsets to a child		** FIX: Add the overflow TO BOTH <body> & <html>
	 from leaving a parent)

	-position: sticky;		* Does nothing alone. If something like top: 20px is defined, then once the viewport top reaches the element w/
					  sticky by 20px, it will follow it until it reaches the end of the parent

	-Understanding the 		* If all elements are fixed and are in the same Z. Then, the html code dictates how they stack (in order seen)
	 Stacking Context:		* Children can not go behind the parent's Z-index AND it can't go above elements that are not related to it. This is because
					  elements that have fixed on them define their own STACKING CONTEXT